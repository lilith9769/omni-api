syntax = "proto3";

package omni.v1beta1;

import "omni/v1beta1/types.proto";
import "omni/v1beta1/trader.proto";

////////////////////////////////////////////////////////////////////
// Resolver requests
////////////////////////////////////////////////////////////////////

// The payload of connection request.
//
// The resolver signs the payload with specified key and sends it to the server in the form of `ConnectRequest`.
message ConnectPayload {
  // Timestamp of request.
  sint64 connect_timestamp = 1;

  // Address of contract holding resolver's stake that allows to participate in protocol.
  // The stake contract holds resolver's info, including list of authorized keys.
  string stake_address = 2;
}

// Signed connection request authenticating the resolver.
message ConnectRequest {
  // ProtoBuf-serialized `ConnectPayload`.
  bytes payload = 1;

  // Public key used by the signature.
  bytes public_key = 2;

  // Ed25519 signature of payload.
  bytes signature = 3;
}

// Resolver's parameters specific to `ESCROW` settlement method
message ResolverEscrowParams {
  // Address of the resolver that should receive tokens offered by the trader.
  string resolver_offer_address = 1;

  // Address of the resolver that must send tokens asked by the trader.
  string resolver_ask_address = 2;
}

// Resolver's parameters specific to `ATOMIC` settlement method
message ResolverAtomicParams {
  // TODO: Define
}

// The request to update swap quote by the resolver.
message UpdateQuoteRequest {
  // ID of request as specified by `QuoteRequestedEvent`.
  string rfq_id = 1;

  // Amount of `offer_asset_address` that the resolver will get.
  string resolver_offer_units = 2;

  // Amount of `ask_asset_address` that the resolver will pay.
  string resolver_ask_units = 3;

  // Parameters specific to settlement method.
  oneof params {
    ResolverEscrowParams escrow = 4;
    //    ResolverAtomicParams atomic = 5;
  }
}

// Requests from resolver.
message ResolverRequest {
  // The unique ID of the request generated by resolver.
  //
  // This field can be used to match requests and corresponding replies sent as `ResolverEvent`.
  //
  // The server doesn't validate contents of this field and injects it in the reply as is.
  // It's recommended to use monotonically increasing atomic integer starting from 1
  // to avoid difficult to diagnose client-side errors.
  uint64 seqno = 1;

  // One of resolver's requests.
  oneof request {
    ConnectRequest connect = 10;
    UpdateQuoteRequest update_quote = 11;
  }
}

////////////////////////////////////////////////////////////////////
// Resolver events
////////////////////////////////////////////////////////////////////

// Notifies the resolver that the quote has been requested by the trader.
message QuoteRequestedEvent {
  // ID of RFQ generated by the server (SHA-256 hex string)
  string rfq_id = 1;

  // The RFQ received from the trader forwarded as is
  QuoteRequest quote_request = 2;

  // Amounts for resolvers adjusted by fees
  oneof resolver_amount {
    // Amount of `offer_asset_address` that the resolver will get
    string offer_units = 3;
    // Amount of `ask_asset_address` that the resolver will pay
    string ask_units = 4;
  }

  // The timestamp (UTC seconds) of RFQ sent by the trader.
  sint64 request_timestamp = 5;

  // Maximum duration since quote generation before the trader must make valid deposit.
  sint64 quote_validity_timeout = 6;

  // Minimum duration since trader's deposit before the resolver may start settling the trade.
  sint64 deposit_settling_delay = 7;

  // Maximum duration since trader's deposit before the resolver must complete the trade.
  sint64 resolve_timeout = 8;
}

// Notifies the resolver that the RFQ has been cancelled by the trader.
message QuoteRequestCancelledEvent {
  // ID of RFQ from prior `QuoteRequestedEvent` (SHA-256 hex string)
  string rfq_id = 1;
}

// Notifies the resolver that the server accepted the quote sent in `UpdateQuoteRequest`.
//
// The resolver can match `UpdateQuoteRequest` & `QuoteAcceptedEvent` using `seqno` field.
message QuoteAcceptedEvent {
  // ID of quote generated by the server (SHA-256 hex string)
  string quote_id = 1;
}

// Notifies the resolver that the server accepted the quote sent in `UpdateQuoteRequest`.
//
// The resolver can match `UpdateQuoteRequest` & `QuoteRejectedEvent` using `seqno` field.
message QuoteRejectedEvent {
  // TODO: Rejection diagnostics
}

// Notifies the resolver that the trader has deposited tokens to escrow contract.
message TradeStartedEvent {
  // ID of RFQ generated by the server (SHA-256 hex string).
  string rfq_id = 1;

  // ID of quote generated by the server (SHA-256 hex string).
  string quote_id = 2;

  oneof params {
    EscrowTradeParams escrow = 11;
  }
}


message ResolverEvent {
  // Contains the `seqno` specified in `ResolverRequest` if the event is a reply to a request.
  // Otherwise this field is empty.
  uint64 seqno = 1;

  // One of resolver's events.
  oneof event {
    QuoteRequestedEvent quote_requested = 10;
    QuoteRequestCancelledEvent quote_request_cancelled = 11;
    QuoteAcceptedEvent quote_accepted = 12;
    QuoteRejectedEvent quote_rejected = 13;
    TradeStartedEvent trade_started = 20;
  }
}

service ResolverGrpc {
  // Connects the resolver to the protocol.
  //
  // Fatal errors (ex: authentication error) cause gRPC error & disconnect.
  // The server will return non-fatal errors in the form of events (ex: QuoteRejectedEvent).
  //
  // The resolver must start communication by sending `ConnectRequest` to authenticate itself.
  rpc Open(stream ResolverRequest) returns (stream ResolverEvent) {}
}
